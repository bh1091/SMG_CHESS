package org.sanjana.hw7.server;

import static com.googlecode.objectify.ObjectifyService.ofy;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Set;

import org.sanjana.hw6.LoginDetails;
import org.sanjana.hw7.Match;
import org.sanjana.hw7.MultiplayerChessService;
import org.sanjana.hw7.Player;

import com.google.appengine.api.channel.ChannelMessage;
import com.google.appengine.api.channel.ChannelService;
import com.google.appengine.api.channel.ChannelServiceFactory;
import com.google.appengine.api.users.User;
import com.google.appengine.api.users.UserService;
import com.google.appengine.api.users.UserServiceFactory;
import com.google.gwt.user.server.rpc.RemoteServiceServlet;
import com.googlecode.objectify.Key;
import com.googlecode.objectify.ObjectifyService;

@SuppressWarnings("deprecation")
public class MultiplayerChessServiceImpl extends RemoteServiceServlet implements MultiplayerChessService
{
	static{
		ObjectifyService.register(Player.class);
		ObjectifyService.register(Match.class);
	}

	private static final long serialVersionUID = 1L;

	UserService userService = UserServiceFactory.getUserService();
	ChannelService channelService = ChannelServiceFactory.getChannelService();

	@Override
	public String match()
	{
		if (userService.isUserLoggedIn()) 
		{
			User user = userService.getCurrentUser();
			String clientID = String.valueOf((long) (Math.random() * 10000));
			String token = channelService.createChannel(clientID);
			String email = user.getEmail();
			String name = user.getNickname();

			Key<Player> playerKey = Key.create(Player.class, email);
			Player player = ofy().load().key(playerKey).get();

			if (player == null) {
				player = new Player(email, name);
				ofy().save().entities(player).now();
			} 
			player.addConnection(clientID);
			ofy().save().entities(player).now();
			return token;
		}
		else 
			return null;
	}


	@Override
	public void automatch() 
	{
		if (userService.isUserLoggedIn()) 
		{
			User user = userService.getCurrentUser();
			Key<Player> playerKey = Key.create(Player.class, user.getEmail());
			Player player = ofy().load().key(playerKey).get();

			List<Player> otherPlayers = ofy().load().type(Player.class).filter("automatch", true).list();

			if (otherPlayers.isEmpty()) {
				player.setAutomatch(true);
				ofy().save().entity(player);
			} 

			else {
				if(otherPlayers.get(0).equals(player)){
					ofy().save().entity(player).now();
					return; 
				}

				Player otherPlayer=otherPlayers.remove(0);
				Date startDate = new Date();
				otherPlayer.setAutomatch(false);

				Key<Player> otherPlayerKey = Key.create(Player.class, otherPlayer.getEmail());

				Match match=new Match(otherPlayerKey,playerKey,startDate,"");
				ofy().save().entity(match).now();
				Key<Match> matchKey = ofy().save().entity(match).now();
				player.addMatch(matchKey);
				otherPlayer.addMatch(matchKey);

				ofy().save().entities(player,otherPlayer,match).now();

				String message1 = "newgame*"+match.getId()+"*W*"+player.getName()+"*"+ 
						player.getEmail() + "*" + startDate;

				String message2 = "newgame*"+match.getId()+"*B*"+otherPlayer.getName()+"*"+ 
						otherPlayer.getEmail() + "*" +startDate;

				Set<String> tokens1 = player.getConnections();
				Set<String> tokens2 = otherPlayer.getConnections();

				for (String connection : tokens1) 
					channelService.sendMessage(new ChannelMessage(connection, message2));

				for (String connection : tokens2) 
					channelService.sendMessage(new ChannelMessage(connection, message1));
			}
		}
	}

	@Override
	public void cancelAutoMatch() 
	{
		if (userService.isUserLoggedIn()) 
		{	
			User user = userService.getCurrentUser();
			Key<Player> playerKey = Key.create(Player.class, user.getEmail());
			Player player = ofy().load().key(playerKey).get();
			player.setAutomatch(false);
			ofy().save().entity(player);
		}
	}

	@Override
	public Boolean emailMatch(String email) 
	{
		if (userService.isUserLoggedIn()) 
		{
			User user = userService.getCurrentUser();
			Key<Player> playerKey = Key.create(Player.class, user.getEmail());
			Player player = ofy().load().key(playerKey).get();
			Key<Player> otherPlayerKey = Key.create(Player.class,email);
			Player otherPlayer = ofy().load().key(otherPlayerKey).get();

			if (otherPlayer == null) {
				otherPlayer=new Player(email,email);
				ofy().save().entity(otherPlayer).now();
			}

			Date startDate = new Date();
			Match match = new Match(playerKey, otherPlayerKey,startDate,"");
			Key<Match> matchKey = ofy().save().entity(match).now();
			player.addMatch(matchKey);
			otherPlayer.addMatch(matchKey);

			ofy().save().entities(player, otherPlayer);

			String message1 = "newgame*"+match.getId()+"*W*"+player.getName()+"*"+ 
					player.getEmail() + "*" +startDate;

			String message2 = "newgame*"+match.getId()+"*B*"+otherPlayer.getName()+"*"+ 
					otherPlayer.getEmail() + "*" + startDate;

			Set<String> tokens1 = player.getConnections();
			Set<String> tokens2 = otherPlayer.getConnections();

			for (String connection : tokens1) {
				channelService.sendMessage(new ChannelMessage(connection, message1));
			}
			for (String connection : tokens2) {
				channelService.sendMessage(new ChannelMessage(connection, message2));
			}
			ofy().save().entities(player, otherPlayer, match).now();
			return true;
		}
		return false;
	}

	@Override
	public void sendMove(String matchID, String stateString) 
	{
		if (userService.isUserLoggedIn()) 
		{
			User user = userService.getCurrentUser();
			Key<Match> matchKey = Key.create(Match.class, matchID);
			Match match = ofy().load().key(matchKey).get();

			Key<Player> playerKey = Key.create(Player.class, user.getEmail());
			Player player = ofy().load().key(playerKey).get();
			Key<Player> otherPlayerKey = match.getOpponent(playerKey);
			Player otherPlayer = ofy().load().key(otherPlayerKey).get();

			match.setState(stateString);
			ofy().save().entity(match).now();

			String message = "move*" + matchID.toString() + "*" + stateString;
			Set<String> tokens = otherPlayer.getConnections();
			ofy().save().entities(otherPlayer, player).now();
			for (String connection : tokens) 
				channelService.sendMessage(new ChannelMessage(connection, message));
		}
	}

	@Override
	public String getMatch(Long matchId)
	{
		User user = userService.getCurrentUser();
		Key<Player> playerKey = Key.create(Player.class, user.getEmail());
		Player player = ofy().load().key(playerKey).get();
		Key<Match> matchKey = Key.create(Match.class, matchId);
		Match match = ofy().load().key(matchKey).get();

		Key<Player> otherPlayerKey = match.getOpponent(playerKey);
		Player opponent = ofy().load().key(otherPlayerKey).get();

		String message = match.getId().toString();
		if (match.getPlayerColor(playerKey).isWhite())
			message += "*W*";
		else
			message += "*B*";

		message+= message+opponent.getName() + "*"+opponent.getEmail() + 
				"*"+match.getDate()+"*"+match.getState();
		ofy().save().entities(match,player,opponent).now();
		return message;
	}

	@Override
	public ArrayList<String> loadAllMatches(LoginDetails user)
	{
		Key<Player> playerKey = Key.create(Player.class, user.getEmailAddress());
		Player player = ofy().load().key(playerKey).get();

		ArrayList<String> results = new ArrayList<String>(player.numberOfMatches());

		for (Match match : ofy().load().keys(player.getMatches()).values()) 
		{
			Key<Player> opponentKey = match.getOpponent(playerKey);
			Player opponent = ofy().load().key(opponentKey).get();

			String message = match.getId().toString();
			if (match.getPlayerColor(playerKey).isWhite())
				message += "*W*";
			else
				message += "*B*";

			results.add( message+opponent.getName() + "*"+opponent.getEmail() + 
					"*"+match.getDate()+"*"+match.getState());

			ofy().save().entities(match, opponent).now();
		}
		ofy().save().entity(player).now();
		return results;
	}

	@Override
	public void removeMatch(Long matchID)
	{
		if (userService.isUserLoggedIn()) 
		{
			User user = userService.getCurrentUser();
			Key<Player> playerKey = Key.create(Player.class,user.getEmail());
			Player player = ofy().load().key(playerKey).get();
			Key<Match> matchKey = Key.create(Match.class, matchID);
			player.removeMatch(matchKey); 
			ofy().save().entity(player).now();

			Match match = ofy().load().key(matchKey).get();
			Player opponent = ofy().load().key(match.getOpponent(playerKey)).get();

			if (! opponent.containsMatch(matchKey))
				ofy().delete().entity(match);

			ofy().save().entities(match, opponent).now();
		}
	}
}