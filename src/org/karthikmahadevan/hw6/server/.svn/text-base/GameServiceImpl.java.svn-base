package org.karthikmahadevan.hw6.server;

import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

import javax.jdo.annotations.PersistenceCapable;
import javax.jdo.annotations.Persistent;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.AddressException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;

import org.karthikmahadevan.hw6.client.GameService;
import org.karthikmahadevan.hw7.Match;
import org.karthikmahadevan.hw7.Player;

import com.google.gwt.user.server.rpc.RemoteServiceServlet;
import com.google.appengine.api.channel.ChannelMessage;
import com.google.appengine.api.channel.ChannelService;
import com.google.appengine.api.channel.ChannelServiceFactory;
import com.google.appengine.api.users.User;
import com.google.appengine.api.users.UserService;
import com.google.appengine.api.users.UserServiceFactory;
import com.googlecode.objectify.Key;
import com.googlecode.objectify.Objectify;
import com.googlecode.objectify.ObjectifyService;

import static com.googlecode.objectify.ObjectifyService.ofy;

@PersistenceCapable
public class GameServiceImpl extends RemoteServiceServlet implements
		GameService {
	/**
	 * 
	 */
	static {
		ObjectifyService.register(Player.class);
		ObjectifyService.register(Match.class);
	}
	private static final long serialVersionUID = 1L;
	@Persistent
	private static String[] clientIDs = { "", "" };

	@Override
	public String getToken(String clientID) {
		// TODO Auto-generated method stub
		ChannelService channelService = ChannelServiceFactory
				.getChannelService();
		String token = channelService.createChannel(clientID);

		if (clientIDs[0] == "") {
			clientIDs[0] = clientID;
		} else {
			clientIDs[1] = clientID;
			ChannelService opponentChannelService = ChannelServiceFactory
					.getChannelService();
			ChannelMessage channelMessage = new ChannelMessage(clientIDs[0],
					"init");
			opponentChannelService.sendMessage(channelMessage);
		}
		return token;
	}

	@Override
	public void updateState(String moveMadeBy, String state) {
		ChannelService opponentChannelService = ChannelServiceFactory
				.getChannelService();
		String opponent;
		if (moveMadeBy.equals(clientIDs[0])) {
			opponent = clientIDs[1];
		} else {
			opponent = clientIDs[0];
		}
		opponentChannelService.sendMessage(new ChannelMessage(opponent, state));
	}

	@Override
	public void testCommunication() {
		ChannelService playerChannelService = ChannelServiceFactory
				.getChannelService();
		ChannelMessage channelMessage = new ChannelMessage(clientIDs[0],
				"test message");
		playerChannelService.sendMessage(channelMessage);
	}

	@Override
	public String addNewConnection() {

		// TODO Auto-generated method stub
		String clientID = String
				.valueOf((long) (Math.random() * (double) 100000));
		String token = createToken(clientID);
		User user = getCurrentUser();
		String email = user.getEmail();
		// ofy().cache(false).delete().type(Player.class).id(email);
		String name = user.getNickname();
		Objectify ofy1 = ofy().transaction();
		ofy1.cache(false);
		Player player = ofy1.load().type(Player.class).id(email).get();
		if (player == null) {
			player = new Player(email, name);
			player.getTokens().add(clientID);
			ofy1.save().entities(player).now();
		} else {
			List<String> tokens = player.getTokens();
			// List<String> tokens = new ArrayList<String>();
			// if (tokens == null) tokens = new ArrayList<String>();
			tokens.add(clientID);
			player.setTokens(tokens);
			List<Long> matches = player.getMatches();
			if (matches == null)
				matches = new ArrayList<Long>();
			player.setMatches(matches);
			ofy1.save().entities(player).now();
		}
		ofy1.getTxn().commit();
		return token;
	}

	private User getCurrentUser() {
		UserService userService = UserServiceFactory.getUserService();
		User user = userService.getCurrentUser();
		return user;
	}

	@Override
	public void getOpponentThroughAutoMatch() {
		User user = getCurrentUser();
		Player curPlayer = ofy().cache(false).load().type(Player.class)
				.id(user.getEmail()).get();
		Player opponent = (Player) ofy().cache(false).load().type(Player.class)
				.filter("availablityForAutoMatch", true)
				.filter("email !=", curPlayer.getEmail()).first().get();
		if (opponent == null) {
			curPlayer.setAvailablityForAutoMatch(true);
			ofy().cache(false).save().entities(curPlayer).now();
		} else {
			createNewMatch(opponent.getEmail(), curPlayer.getEmail(), true);
		}
	}

	private String createToken(String clientID) {
		ChannelService channelService = ChannelServiceFactory
				.getChannelService();
		String token = channelService.createChannel(clientID);
		return token;
	}

	private void sendMessage(String clientID, String message) {
		ChannelService channelService = ChannelServiceFactory
				.getChannelService();
		ChannelMessage channelMessage = new ChannelMessage(clientID, message);
		channelService.sendMessage(channelMessage);
	}

	@Override
	public void updateMove(Long MatchID, String state) {
		Objectify ofy1 = ofy().transaction();
		ofy1.cache(false);
		Match match = ofy1.load().type(Match.class).id(MatchID).get();
		match.setState(state);
		ofy1.save().entities(match).now();
		Player white, black;
		String whiteEmail = match.getWhite();
		String blackEmail = match.getBlack();

		white = ofy1.load().type(Player.class).id(whiteEmail).get();
		black = ofy1.load().type(Player.class).id(blackEmail).get();
		ofy1.getTxn().commit();

		sendMessageToPlayer(white,
				state.toString() + ",MatchID=" + String.valueOf(MatchID));
		sendMessageToPlayer(black,
				state.toString() + ",MatchID=" + String.valueOf(MatchID));
	}

	private void sendMessageToPlayer(Player player, String message) {
		for (int i = 0; i < player.getTokens().size(); ++i) {
			sendMessage(player.getTokens().get(i), message);
		}
	}

	@Override
	public List<Long> getMatches() {
		User user = getCurrentUser();
		Player player = ofy().cache(false).cache(false).load()
				.key(Key.create(Player.class, user.getEmail())).get();
		return player.getMatches();
	}

	@Override
	public String getMatchInfo(Long matchID) {
		Match match = ofy().cache(false).load().type(Match.class).id(matchID)
				.get();
		StringBuilder matchInfo = new StringBuilder(String.valueOf(matchID));

		matchInfo.append("~" + match.getState() + "~");

		User user = getCurrentUser();
		String email = user.getEmail();
		if (email.equals(match.getWhite())) {
			matchInfo.append("W");
			matchInfo.append("~");
			matchInfo.append(match.getBlack());
		} else {
			matchInfo.append("B");
			matchInfo.append("~");
			matchInfo.append(match.getWhite());
		}

		return matchInfo.toString();
	}

	@Override
	public void deleteMatch(Long matchID) {
		// TODO Auto-generated method stub
		User user = getCurrentUser();
		String email = user.getEmail();

		Player curPlayer = ofy().cache(false).load().type(Player.class)
				.id(email).get();
		List<Long> curPlayerMatches = curPlayer.getMatches();
		curPlayerMatches.remove(matchID);
		ofy().cache(false).save().entities(curPlayer).now();

		Match match = ofy().cache(false).load().type(Match.class).id(matchID)
				.get();
		String whiteEmail = match.getWhite();
		String opponentEmail;
		if (email.equals(whiteEmail)) {
			opponentEmail = match.getBlack();
		} else {
			opponentEmail = whiteEmail;
		}
		Player opponentPlayer = ofy().cache(false).load().type(Player.class)
				.id(opponentEmail).get();
		if (!opponentPlayer.getMatches().contains(matchID)) {
			ofy().cache(false).delete().type(Match.class).id(matchID);
		}
	}

	@Override
	public String playWith(String opponentEmail) {
		String status;
		Player opponent = ofy().cache(false).load().type(Player.class)
				.id(opponentEmail).get();
		if (opponent == null) {
			opponent = new Player(opponentEmail, opponentEmail);
			ofy().cache(false).save().entities(opponent).now();
		}
		User user = getCurrentUser();
		createNewMatch(user.getEmail(), opponentEmail, false);
		Properties props = new Properties();
		Session session = Session.getDefaultInstance(props, null);

		String msgBody = user.getNickname()
				+ " has invited you to play a game of chess :)"
				+ "Please visit http://chess-karthik.appspot.com/karthikmahadevan.html to get started.";

		try {
			Message msg = new MimeMessage(session);
			msg.setFrom(new InternetAddress(user.getEmail(), user.getNickname()));
			msg.addRecipient(Message.RecipientType.TO, new InternetAddress(
					opponentEmail, "Buddy"));
			msg.setSubject("Invitation to play a game of chess!");
			msg.setText(msgBody);
			Transport.send(msg);
			status = "Invitation sent!";
		} catch (AddressException e) {
			status = "That is an invaid email address!";
		} catch (MessagingException e) {
			status = "An error occurred sending an invitation!";
		} catch (UnsupportedEncodingException e) {
			status = "An error occurred sending an invitation!";
		}
		return status;
	}

	private void createNewMatch(String whiteEmail, String blackEmail,
			boolean disableAutoMatch) {
		Objectify ofy1 = ofy().transaction();
		ofy1.cache(false);
		Match match = new Match(whiteEmail, blackEmail);
		ofy1.save().entities(match).now();
		Player player1 = ofy1.load().type(Player.class).id(whiteEmail).get();
		List<Long> player1Matches = player1.getMatches();
		if (player1Matches == null) {
			player1Matches = new ArrayList<Long>();
		}
		player1Matches.add(match.getMatchID());
		player1.setMatches(player1Matches);

		Player player2 = ofy1.load().type(Player.class).id(blackEmail).get();
		List<Long> player2Matches = player2.getMatches();
		if (player2Matches == null) {
			player2Matches = new ArrayList<Long>();
		}
		player2Matches.add(match.getMatchID());
		player2.setMatches(player2Matches);

		if (disableAutoMatch) {
			player1.setAvailablityForAutoMatch(false);
			player2.setAvailablityForAutoMatch(false);
		}
		ofy1.save().entities(player1).now();
		ofy1.save().entities(player2).now();
		ofy1.getTxn().commit();

		String message = match.getMatchID() + "~~";
		sendMessageToPlayer(player1, message + "W~" + player2.getName());
		sendMessageToPlayer(player2, message + "B~" + player1.getName());
	}

	@Override
	public String getCurrentUserEmail() {
		User user = getCurrentUser();
		return user.getEmail();
	}
}
