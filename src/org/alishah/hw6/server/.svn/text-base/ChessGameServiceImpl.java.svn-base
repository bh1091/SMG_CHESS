package org.alishah.hw6.server;

import java.util.ArrayList;
import java.util.List;


import com.google.appengine.api.channel.ChannelMessage;
import com.google.appengine.api.channel.ChannelService;
import com.google.appengine.api.channel.ChannelServiceFactory;
import com.google.appengine.api.users.User;
import com.google.appengine.api.users.UserService;
import com.google.appengine.api.users.UserServiceFactory;
import com.google.gwt.user.server.rpc.RemoteServiceServlet;
import com.googlecode.objectify.Key;
import com.googlecode.objectify.ObjectifyService;

import org.alishah.hw3.StateSerializer;
import org.alishah.hw6.client.ChessGameService;
import org.alishah.hw6.client.PlayerInformation;
import org.alishah.hw6.client.MatchInformation;

import org.chenji.hw2.StateChangerImpl;

import org.shared.chess.IllegalMove;
import org.shared.chess.Move;
import org.shared.chess.State;
import org.shared.chess.StateChanger;

import static com.googlecode.objectify.ObjectifyService.ofy;

public class ChessGameServiceImpl extends RemoteServiceServlet implements
    ChessGameService {
	
	/**
   * Autogenerated serialized version
   */
  private static final long serialVersionUID = 8503565723434973317L;
  
  private static final String MESSAGE_SEPERATOR = " ";
  private static final String DEFAULT_RANK = "1500";

	static {
		ObjectifyService.register(MatchInformation.class);
		ObjectifyService.register(PlayerInformation.class);
	}
	
	ChannelService connectionService = ChannelServiceFactory.getChannelService();
	UserService googleUserService = UserServiceFactory.getUserService();
	StateChanger stateChanger = new StateChangerImpl();
  
	private Key<PlayerInformation> getPlayerKey(String emailAddress) {
		return Key.create(PlayerInformation.class, emailAddress);
	}
	private PlayerInformation getPlayerInformation(String emailAddress) {
		Key<PlayerInformation> currentPlayerKey = getPlayerKey(emailAddress);
		return ofy().load().key(currentPlayerKey).get();
	}
	
	@Override
  public String userConnect() {
	  if (googleUserService.isUserLoggedIn()) {
	  	User currentUser = googleUserService.getCurrentUser();
	  	PlayerInformation currentPlayerInformation =
	  			getPlayerInformation(currentUser.getEmail());
	  	if (currentPlayerInformation == null) {
	  		currentPlayerInformation = new PlayerInformation(currentUser.getEmail(),
	  																										 currentUser.getNickname());
	  		ofy().save().entity(currentPlayerInformation);
	  	}
	  	String connectionId = currentUser.getEmail()
	  										  + MESSAGE_SEPERATOR
	  										  + currentPlayerInformation.numberOfConns();
	  	return connectionService.createChannel(connectionId);
	  }
	  return null;
  }

	@Override
  public String beginMatchWithId(Long match) {
	  if (googleUserService.isUserLoggedIn()) {
	  	if (match != null) {
	  		User currentUser = googleUserService.getCurrentUser();
	  		Key<PlayerInformation> playerInfoKey =
	  				Key.create(PlayerInformation.class, currentUser.getEmail());
	  		Key<MatchInformation> matchInfoKey = 
	  				Key.create(MatchInformation.class, match);
	  		
	  		MatchInformation matchInfo = ofy().load().key(matchInfoKey).get();
	  		
	  		String message = matchInfo.matchId().toString() + " ";
	  		message += matchInfo.getPlayerColor(playerInfoKey).isBlack() ? "b " : "w ";
	  		message += matchInfo.currentState();
	  		return message;
	  	}
	  }
	  return "NaN";
  }

	@Override
  public String getCurrentLoginStatus(String user) {
		if (googleUserService.isUserLoggedIn()) {
			User currentUser = googleUserService.getCurrentUser();
			PlayerInformation playerInfo =
					getPlayerInformation(currentUser.getEmail());
			if (playerInfo == null) {
				return "loggedin" + 
						MESSAGE_SEPERATOR +
						currentUser.getNickname() +
						MESSAGE_SEPERATOR + 
						currentUser.getEmail() +
						MESSAGE_SEPERATOR + 
						DEFAULT_RANK +
						MESSAGE_SEPERATOR +
						googleUserService.createLogoutURL(user);
			} else {
				return "loggedin" +
						MESSAGE_SEPERATOR +
						playerInfo.playerName() +
						MESSAGE_SEPERATOR +
						playerInfo.emailAddress() +
						MESSAGE_SEPERATOR +
						playerInfo.ranking() + 
						MESSAGE_SEPERATOR +
						googleUserService.createLogoutURL(user);
			}
		} else {
			return "loggedout" + 
					MESSAGE_SEPERATOR +
					googleUserService.createLoginURL(user);
		}
  }
	
	private String createNewMatchMessage(MatchInformation m, PlayerInformation p, String color) {
		return "newmatch"
				+ MESSAGE_SEPERATOR 
				+ m.matchId() 
				+ MESSAGE_SEPERATOR
				+ color 
				+ MESSAGE_SEPERATOR
				+ p.emailAddress()
				+ MESSAGE_SEPERATOR
				+ p.playerName()
				+ MESSAGE_SEPERATOR
				+ p.ranking()
				+ MESSAGE_SEPERATOR
				+ m.matchCreated().getTime()
				+ MESSAGE_SEPERATOR;
	}

	@Override
  public Boolean findMatchByEmail(String email) {
	  if (googleUserService.isUserLoggedIn()) {
	  	User currentUser = googleUserService.getCurrentUser();
	  	
	  	Key<PlayerInformation> playerOneKey =
	  			getPlayerKey(currentUser.getEmail());
	  	Key<PlayerInformation> playerTwoKey =
	  			getPlayerKey(email);
	  	
	  	PlayerInformation playerOneInformation =
	  			getPlayerInformation(currentUser.getEmail());
	  	PlayerInformation playerTwoInformation =
	  			getPlayerInformation(email);
	  	if (playerTwoInformation == null) {
	  		return Boolean.FALSE;
	  	}
	  	
	  	MatchInformation newMatch = new MatchInformation("",
	  																									 playerOneKey,
	  																									 playerTwoKey);
	  	
	  	Key<MatchInformation> matchKey = ofy().save().entity(newMatch).now();
	  	
	  	playerOneInformation.addMatch(matchKey);
	  	playerTwoInformation.addMatch(matchKey);
	  	
	  	ofy().save().entities(playerOneInformation, playerTwoInformation);
	  	String playerMessage = createNewMatchMessage(newMatch, playerTwoInformation, "W");
	  	
	  	for (String connectionName : playerOneInformation.currentConnections()) {
	  		connectionService.sendMessage(new ChannelMessage(connectionName, playerMessage));
	  	}
	  	
	  	playerMessage = createNewMatchMessage(newMatch, playerOneInformation, "B");
	  	
	  	for (String connectionName : playerTwoInformation.currentConnections()) {
	  		connectionService.sendMessage(new ChannelMessage(connectionName, playerMessage));
	  	}
	  	
	  	return Boolean.TRUE;
	  }
	  return Boolean.FALSE;
  }

	@Override
  public void removeMatch(Long match) {
		if (googleUserService.isUserLoggedIn()) {
			User currentUser = googleUserService.getCurrentUser();
			Key<PlayerInformation> playerOneKey = getPlayerKey(currentUser.getEmail());
			PlayerInformation playerOneInfo = getPlayerInformation(currentUser.getEmail());
			
			Key<MatchInformation> matchKey = Key.create(MatchInformation.class, match);
			
			playerOneInfo.removeMatch(matchKey);
			ofy().save().entity(playerOneInfo);
			
			MatchInformation matchInfo =
					ofy().load().key(matchKey).get();
			PlayerInformation playerInfo =
					ofy().load().key(matchInfo.getOpponent(playerOneKey)).get();
			if (!playerInfo.isInMatch(matchKey)) {
				ofy().delete().entity(matchInfo);
			}
		}
	  
  }

	@Override
  public String[] getMatchNames() {
	  if (googleUserService.isUserLoggedIn()) {
	  	User currentUser = googleUserService.getCurrentUser();
	  	Key<PlayerInformation> playerInfoKey = getPlayerKey(currentUser.getEmail());
	  	PlayerInformation playerInfo = getPlayerInformation(currentUser.getEmail());
	  	List<String> results = new ArrayList<String>(playerInfo.numberOfMatches());
	  	for (MatchInformation match : ofy().load().keys(playerInfo.allMatches()).values()) {
	  		PlayerInformation opposingPlayerInfo =
	  				ofy().load().key(match.getOpponent(playerInfoKey)).get();
	  		String color = match.getPlayerColor(playerInfoKey).isWhite() ? "W" : "B";
	  		String message = match.matchId().toString() 
	  				+ MESSAGE_SEPERATOR
	  				+ color
	  				+ MESSAGE_SEPERATOR
	  				+ opposingPlayerInfo.playerName()
	  				+ MESSAGE_SEPERATOR
	  				+ opposingPlayerInfo.emailAddress()
	  				+ MESSAGE_SEPERATOR
	  				+ opposingPlayerInfo.ranking()
	  				+ MESSAGE_SEPERATOR
	  				+ match.matchCreated().getTime()
	  				+ MESSAGE_SEPERATOR
	  				+ match.currentState();
	  		results.add(message);
	  	}
	  	String[] list = new String[results.size()];
	  	list = results.toArray(list);
	  	return list;
	  }
	  return new String[0];
  }

	@Override
  public void matchmakeAuto() {
	  if (googleUserService.isUserLoggedIn()) {
	  	User currentUser = googleUserService.getCurrentUser();
	  	Key<PlayerInformation> playerInfoKey = getPlayerKey(currentUser.getEmail());
	  	PlayerInformation playerInfo = getPlayerInformation(currentUser.getEmail());
	  	List<PlayerInformation> availablePlayersToMatch =
	  			ofy().load().type(PlayerInformation.class).filter("automatch", true).list();
	  	if (availablePlayersToMatch.isEmpty()) {
	  		playerInfo.setAutomatchable(true);
	  		ofy().save().entity(playerInfo);
	  	} else {
	  		PlayerInformation opponentInformation = availablePlayersToMatch.remove(0);
	  		opponentInformation.setAutomatchable(false);
	  		Key<PlayerInformation> opponentKey = getPlayerKey(opponentInformation.emailAddress());
	  		MatchInformation match = new MatchInformation("", playerInfoKey, opponentKey);
	  		Key<MatchInformation> matchKey = ofy().save().entity(match).now();
	  		playerInfo.addMatch(matchKey);
	  		opponentInformation.addMatch(matchKey);
	  		ofy().save().entities(playerInfo, opponentInformation, match).now();
	  		String playerMessage = createNewMatchMessage(match, opponentInformation, "B");
		  	for (String connectionName : playerInfo.currentConnections()) {
		  		connectionService.sendMessage(new ChannelMessage(connectionName, playerMessage));
		  	}
		  	
		  	playerMessage = createNewMatchMessage(match, playerInfo, "W");
		  	for (String connectionName : opponentInformation.currentConnections()) {
		  		connectionService.sendMessage(new ChannelMessage(connectionName, playerMessage));
		  	}
	  	}
	  }
  }

	@Override
  public void cancelMatchmaking() {
	  if (googleUserService.isUserLoggedIn()) {
	  	User currentUser = googleUserService.getCurrentUser();
	  	PlayerInformation playerInfo = getPlayerInformation(currentUser.getEmail());
	  	playerInfo.setAutomatchable(false);
	  	ofy().save().entity(playerInfo).now();
	  }
  }

	@Override
  public String makeMoveInMatch(Long match, String move) {
		if (googleUserService.isUserLoggedIn()) {
			Key<MatchInformation> matchKey = Key.create(MatchInformation.class, match);
			MatchInformation matchInfo = ofy().load().key(matchKey).get();
			
			State state = StateSerializer.deserialize(matchInfo.currentState());
			Move serializedMove = StateSerializer.deserializeMove(move);
			try {
				stateChanger.makeMove(state, serializedMove);
			} catch (IllegalMove e) {
				return matchInfo.currentState();
			}
			matchInfo.setState(StateSerializer.serialize(state));
			ofy().save().entity(matchInfo);
			
			User currentUser = googleUserService.getCurrentUser();
			Key<PlayerInformation> playerKey = getPlayerKey(currentUser.getEmail());
			Key<PlayerInformation> opponentKey = matchInfo.getOpponent(playerKey);
			
			PlayerInformation opponent = ofy().load().key(opponentKey).get();
			
			String moveMessage = "move "
					+ match.toString()
					+ MESSAGE_SEPERATOR
					+ StateSerializer.serialize(state)
					+ MESSAGE_SEPERATOR
					+ move;
			
			for (String connection : opponent.currentConnections()) {
				connectionService.sendMessage(new ChannelMessage(connection, moveMessage));
			}
			
			return StateSerializer.serialize(state);
		}
		return StateSerializer.serialize(new State());
  }

}
