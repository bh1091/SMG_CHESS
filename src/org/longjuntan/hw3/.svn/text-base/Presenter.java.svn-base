package org.longjuntan.hw3;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.longjuntan.hw2.StateChangerImpl;
import org.longjuntan.hw2_5.StateExplorerImpl;
import org.longjuntan.hw6.client.GameService;
import org.longjuntan.hw6.client.GameServiceAsync;
import org.shared.chess.Color;
import org.shared.chess.GameResult;
import org.shared.chess.Move;
import org.shared.chess.Piece;
import org.shared.chess.PieceKind;
import org.shared.chess.Position;
import org.shared.chess.State;

import com.google.gwt.appengine.channel.client.Channel;
import com.google.gwt.appengine.channel.client.ChannelError;
import com.google.gwt.appengine.channel.client.ChannelFactoryImpl;
import com.google.gwt.appengine.channel.client.Socket;
import com.google.gwt.appengine.channel.client.SocketListener;
import com.google.gwt.core.shared.GWT;
import com.google.gwt.user.client.Window;
import com.google.gwt.user.client.rpc.AsyncCallback;
//import com.google.appengine.api.users.User;
//import com.google.appengine.api.users.UserService;
//import com.google.appengine.api.users.UserServiceFactory;

public class Presenter {
	private Position promoteTo = null;
	private PieceKind promotion = null;
	private Position selected;
	private State state;
	private StateChangerImpl sc = new StateChangerImpl();
	private StateExplorerImpl se = new StateExplorerImpl();
	private Set<Position> possibleMoves = new HashSet<Position>();
	private GameServiceAsync gameSvc = GWT.create(GameService.class);
	private Channel channel;
	private String email;
	private Socket socket;
	private Color turn;
	private String matchId;

	// private UserService userService = UserServiceFactory.getUserService();
	// private User user = userService.getCurrentUser();

	public interface View {
		/**
		 * Renders the piece at this position. If piece is null then the
		 * position is empty.
		 */
		void setPiece(int row, int col, Piece piece);

		/**
		 * Turns the highlighting on or off at this cell. Cells that can be
		 * clicked should be highlighted.
		 */
		void setHighlighted(int row, int col, boolean highlighted);

		/**
		 * Indicate whose turn it is.
		 */
		// void setWhoseTurn(Color color);
		void setWhoseTurn(Boolean color);

		/**
		 * Indicate whether the game is in progress or over.
		 */
		void setGameResult(GameResult gameResult);

		/**
		 * Turns the highlight on or off at this cell if it's a possible move.
		 * Cells that can be clicked should be highlighted.
		 */
		void setPossibleMoves(Position p, boolean possible);

		void setPromotion(Color c);

		void setColor(Color color);
		
		/**
		 * Adds a new history item
		 */
		void updateHistory();

		/**
		 * Shows animation for the piece in position p
		 * 
		 * @param p
		 *            the position for the piece
		 */
		void animation(Position p);

//		void setMatchList(String id);
		void setMatchList(List<String> list);
		
//		List<String> loadMatchList(String email);

	}

	public Presenter() {
		promoteTo = null;
		promotion = null;
		sc = new StateChangerImpl();
		se = new StateExplorerImpl();
		possibleMoves = new HashSet<Position>();
		gameSvc = GWT.create(GameService.class);
	}

	private View view;

	public void setView(View view) {
		this.view = view;
	}

	public void setState(State state) {
		this.state = state;
		view.setWhoseTurn(turn == state.getTurn());
		view.setGameResult(state.getGameResult());
		for (int r = 0; r < 8; r++) {
			for (int c = 0; c < 8; c++) {
				view.setPiece(State.ROWS - 1 - r, c, state.getPiece(r, c));
			}
		}
	}

	/**
	 * Set state as a new state
	 */
	public void init() {
		// System.out.println("a a a ");

		AsyncCallback<String> callback = new AsyncCallback<String>() {
			public void onFailure(Throwable caught) {
				Window.alert("inittest");
			}

			@Override
			public void onSuccess(String result) {
				
				// TODO Auto-generated method stub
	/*			turn = Color.valueOf(result.substring(0, 5));
				view.setColor(turn);
				if (turn == Color.BLACK) {
					matchId = result.substring(5, 9);
					channel = new ChannelFactoryImpl().createChannel(result
							.substring(9));
				} else {
					channel = new ChannelFactoryImpl().createChannel(result
							.substring(5));
				}*/
//				Window.alert(result);
//				String[] items = result.split("|");
//				id = items[0];
//				channel = new ChannelFactoryImpl().createChannel(items[1]);
				channel = new ChannelFactoryImpl().createChannel(result);
				socket = channel.open(new SocketListener() {
					@Override
					public void onOpen() {
						Window.alert("Channel opened!");
					}

					@Override
					public void onMessage(String message) {
						if(message.startsWith("N")){
							Window.alert(message);
						}
						if (message.startsWith("SID")) {
							matchId = message.substring(3, 7);
							return;
						}
						// TODO

						// String from = positions[0].replaceAll("(",
						// "").replaceAll(")", "");
						// Position fromPos = new
						// Position(Integer.parseInt(from.split(",")[0]),Integer.parseInt(from.split(",")[1]));
						// String to = positions[1].replaceAll("(",
						// "").replaceAll(")", "");
						// Position toPos = new
						// Position(Integer.parseInt(to.split(",")[0]),Integer.parseInt(to.split(",")[1]));
						// Move other = new Move(fromPos, toPos, promotion);
						// sc.makeMove(state, other);
						// setState(state);
						// Position from = getPositionFromString(positions[0]);
						// Position to = getPositionFromString(positions[1]);
						// Move other = new Move(from, to, promotion);
						Window.alert(message);
						if (message.startsWith("MOVE")) {
							String[] entries = message.substring(4).split(" ");
							if(entries[0].equals(matchId)){
								Move move = Utils.getMoveFromString(entries[1]);
								sc.makeMove(state, move);
								setState(state);
							}
						}

						// Window.alert("Received: "
						// // + message
						// // + positions[0]+ positions[1]
						// +" Move:"+getMoveFromString(message).toString()
						// ); ;
					}

					@Override
					public void onError(ChannelError error) {
						Window.alert("Channel error: " + error.getCode()
								+ " : " + error.getDescription());
					}

					@Override
					public void onClose() {
						Window.alert("Channel closed!");
					}
				});
			}
		};

		// Make the call to the stock price service.
		// should change "test" into Token
		// gameSvc.join(user.getUserId(), callback);
		// gameSvc.join("foo",callback);
		gameSvc.join(callback);
		
		
		AsyncCallback<List<String>> callback2 = new AsyncCallback<List<String>>() {

			@Override
			public void onFailure(Throwable caught) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void onSuccess(List<String> result) {
				if(result!=null)
				view.setMatchList(result);				
			}
		};
		gameSvc.loadMatchList(email, callback2);
		
//		state = new State();
//		setState(state);
	}
	
	public void setEmail(String email){
		this.email = email;
	}
	public void load(String matchId){
		this.matchId = matchId;
		AsyncCallback<String> callback = new AsyncCallback<String>() {

			@Override
			public void onFailure(Throwable caught) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void onSuccess(String result) {
				// TODO Auto-generated method stub
				
			} };
		gameSvc.load(matchId, callback); 
		
	}
	
	public void createMatch(String opponent){
		AsyncCallback<String> callback = new AsyncCallback<String>(){

			@Override
			public void onFailure(Throwable caught) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void onSuccess(String result) {
				Window.alert(result);
				// TODO Auto-generated method stub
				turn = (result.charAt(1)=='W')?Color.WHITE:Color.BLACK;
				int i = result.indexOf("@");
				matchId = result.substring(2, i);
				state = Utils.setStateByHistory(result.substring(i+1));
				setState(state);
			}
			
		};
		
		gameSvc.createMatch(opponent,callback);
	}

	public void promote() {
		playerAction(promoteTo);
	}

	public void selectCell(int row, int col) {
		if (state.getTurn() != turn) {
			return;
		}
		if (state.getGameResult() != null) {
			return;
		}
		playerAction(new Position(row, col));
	}

	/**
	 * Helper function for selectCell, helping make the move
	 * 
	 * @param pos
	 */
	private void playerAction(Position pos) {

		refresh();
		if (!possibleMoves.contains(pos)) {
			if (state.getPiece(pos) == null) {
				return;
			} else {
				if (!state.getPiece(pos).getColor().equals(state.getTurn())) {
					return;
				}
			}
			possibleMoves.clear();
			promoteTo = null;
			selectPiece(pos);
		} else {
			Piece piece = state.getPiece(selected);
			if (piece.getKind() == PieceKind.PAWN
					&& (pos.getRow() == (piece.getColor().isWhite() ? 7 : 0) && promotion == null)) {
				view.setPromotion(state.getPiece(selected).getColor());
				promoteTo = pos;
			} else {
				changeMove(new Move(selected, pos, promotion));
				// sc.makeMove(state, new Move(selected, pos, promotion));
				// selected = null;
				// promotion = null;
				// promoteTo = null;
				// possibleMoves.clear();
				// setState(state);
				// view.animation(pos);
				// view.updateHistory();
			}
		}
	}

	private void changeMove(Move move) {
		// Initialize the service proxy.
		System.out.println("a a a !!");
		if (gameSvc == null) {
			gameSvc = GWT.create(GameService.class);
		}

		// Set up the callback object.
		AsyncCallback<String> callback = new AsyncCallback<String>() {
			public void onFailure(Throwable caught) {
				Window.alert("changemovetest");
			}

			public void onSuccess(String result) {
				// 获取token ，factory根据token建立channel

				Move move = Utils.getMoveFromString(result);

				sc.makeMove(state, move);
				selected = null;
				promotion = null;
				promoteTo = null;
				possibleMoves.clear();
				setState(state);
				view.animation(move.getTo());
				view.updateHistory();
			}
		};

		// Make the call to the stock price service.
		// should change "test" into Token
		// gameSvc.sendMove("foo",move, callback);
		gameSvc.sendMove(matchId, move.toString(), callback);
	}

	private void selectPiece(Position pos) {
		selected = pos;
		view.setHighlighted(pos.getRow(), pos.getCol(), true);
		for (Move move : se.getPossibleMovesFromPosition(state, selected)) {
			// Enable highlight
			possibleMoves.add(move.getTo());
			view.setPossibleMoves(move.getTo(), true);
		}
	}

	/**
	 * Clear the highlighted part from the board
	 */
	private void refresh() {
		if (selected != null) {
			view.setHighlighted(selected.getRow(), selected.getCol(), false);
		}
		if (possibleMoves.size() != 0) {
			for (Position p : possibleMoves) {
				view.setPossibleMoves(p, false);
			}
		}
	}

	/**
	 * Gets the history for current state
	 * 
	 * @return the history token in a String type
	 */
	public String getHistory() {
		return Utils.getHistory(state);
	}

	/**
	 * Sets the piece kind for promotion
	 * 
	 * @param kind
	 */
	public void setPromotionKind(PieceKind kind) {
		promotion = kind;
	}

	/*private Move getMoveFromString(String string) {
		string = string.trim();
		PieceKind pk = null;
		if (string.contains("promoting to")) {
			// string.replaceAll(")", "");
			// String substring[] = string.split(" (promoting to ");
			pk = PieceKind.valueOf(string.substring(27, string.length() - 1));
		}
		String[] positions = string.split("->");
		Position from = getPositionFromString(positions[0]);
		Position to = getPositionFromString(positions[1]);
		return new Move(from, to, pk);

	}

	private Position getPositionFromString(String string) {
		int row = Integer.parseInt(string.substring(1, 2));
		int col = Integer.parseInt(string.substring(3, 4));
		return new Position(row, col);
	}*/
}
