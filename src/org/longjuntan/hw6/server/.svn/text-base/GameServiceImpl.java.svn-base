package org.longjuntan.hw6.server;

import static com.googlecode.objectify.ObjectifyService.ofy;

import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

import org.longjuntan.hw6.client.GameService;
import org.longjuntan.hw7.DAO;
import org.longjuntan.hw7.Match;
import org.longjuntan.hw7.Player;
import org.longjuntan.hw7.objectifyDAO;

import com.google.appengine.api.channel.ChannelMessage;
import com.google.appengine.api.channel.ChannelService;
import com.google.appengine.api.channel.ChannelServiceFactory;
import com.google.appengine.api.users.User;
import com.google.appengine.api.users.UserService;
import com.google.appengine.api.users.UserServiceFactory;
import com.google.gwt.user.server.rpc.RemoteServiceServlet;
import com.googlecode.objectify.Key;
import com.googlecode.objectify.ObjectifyService;

@SuppressWarnings("serial")
public class GameServiceImpl extends RemoteServiceServlet implements
		GameService {

	// private String[] clientIDs = new String[2];
	// private final int SESSION_KEY_SIZE = 4;
	private static Queue<String> waitingPlayer = new LinkedList<String>();
	// private Map<String, Game> matchMap = new HashMap<String, Game>();
	private static DAO dao = new objectifyDAO();

	static {
		ObjectifyService.register(Match.class);
		ObjectifyService.register(Player.class);
	}

	@Override
	// public Move sendMove(String clientID, Move move) {
	public String sendMove(String matchId, String move) {
		ChannelService channelService = ChannelServiceFactory
				.getChannelService();
		UserService userService = UserServiceFactory.getUserService();
		User user = userService.getCurrentUser();
		// String token = channelService.createChannel(client);
		// Game current = matchMap.get(sessionID);
		Match current = dao.getMatch(matchId);
		current.makeMove(move);
		dao.saveMatch(current);
		
		for(String channel:current.getOpponent(user.getEmail()).getChannels()){
			channelService.sendMessage(new ChannelMessage(channel, "MOVE"+current.getMatchId()+" "+move));
		}
		/*
		channelService.sendMessage(new ChannelMessage(current.getOpponent((user
				.getUserId())), move));*/
		// System.out.println("User "+ user.getUserId()+ " send move "+
		// move+" User "
		// +getOther(user.getUserId()));

		return move;
	}

	public static void disconnect(String email) {
		if (waitingPlayer.contains(email)) {
			waitingPlayer.remove(email);
		}
	}

	@Override
	public String join() {
		// public String join(String clientID) {
		// if (user != null) {
		// // Window.alert("Welcome"+user.getNickname());
		// }else{
		// // Window.alert("No user!");
		// userService.createLoginURL("/longjuntan.html");

		// }
		ChannelService channelService = ChannelServiceFactory
				.getChannelService();

		UserService userService = UserServiceFactory.getUserService();
		User user = userService.getCurrentUser();
		// String userID = user.getUserId();
		String email = user.getEmail();
		Player player = getOrCreatePlayer(email);
		// Match match;
//		if ((player = dao.getPlayer(email)) == null) {
//			player = new Player(email, user.getNickname());
//		}
		/*
		 * // if(opponent == null){ if(true){ if(waitingPlayer.isEmpty()){
		 * waitingPlayer.add(email); dao.savePlayer(player); // return
		 * "waiting"; }else{ System.out.println("WaitingPlayer"); for(String s :
		 * waitingPlayer){ System.out.println(s); }
		 * System.out.println("End of WaitingPlayer"); String waiting =
		 * waitingPlayer.poll(); match = new Match(waiting+email); Player white
		 * = dao.getPlayer(waiting); match.setPlayer(white,player); // String
		 * whiteToken =
		 * channelService.createChannel(waiting+match.getMatchId()); // String
		 * blackToken = channelService.createChannel(email+match.getMatchId());
		 * // String whiteToken = channelService.createChannel(waiting); //
		 * String blackToken = channelService.createChannel(email);
		 * dao.createMatchTransction(match,white,player); } }
		 */

		String clientId = email +" "+ Long.toString(new Date().getTime());
		String token = channelService.createChannel(clientId);
		System.out.println("Before: Add channel to "+ player.toString()+player.getChannels().size());
		player.addChannels(clientId);
		dao.savePlayer(player);
		System.out.println("After: Add channel to "+ player.toString()+player.getChannels().size());
		/*
		 * if(waitingPlayer==null){ waitingPlayer = userID; // } //
		 * if(clientIDs[0]==null){ // clientIDs[0] = userID; return
		 * "WHITE"+token; }else{ String sessionID; do{ sessionID =
		 * SessionID.generate(SESSION_KEY_SIZE);
		 * }while(matchMap.containsKey(sessionID)); matchMap.put(sessionID, new
		 * Game(waitingPlayer,userID)); channelService.sendMessage(new
		 * ChannelMessage(waitingPlayer, "SID"+sessionID)); waitingPlayer =
		 * null; System.out.println("BLACK"+sessionID+token); return
		 * "BLACK"+sessionID+token;
		 * 
		 * } // TODO Auto-generated method stub
		 * 
		 * // System.out.println("Now join "+ userID); // for(String s:
		 * clientIDs){ // System.out.println("ClientID "+ s); // }
		 */
		/*
		 * System.out.println("Iterate the player list:"); for (Player p :
		 * dao.getPlayer()) { System.out.println(p.toString()); }
		 * System.out.println("End of Iteration");
		 */
		System.out.println("Token: " +token);
//		return email+"|"+token;
		return token;
	}

	@Override
	public String load(String matchId) {
		ChannelService channelService = ChannelServiceFactory
				.getChannelService();
		UserService userService = UserServiceFactory.getUserService();
		User user = userService.getCurrentUser();
		String email = user.getEmail();
		StringBuilder sb = new StringBuilder();
		Match match = dao.getMatch(matchId);
		Player player = dao.getPlayer(email);
		sb.append(matchId).append(">"); 
		sb.append(match.getColor(email));
		
		// TODO Auto-generated method stub
		return null;
	}
	
//	@Override
//	public List<String> loadMatchList(String email){
//		return null;
//	}

	@Override
	public String createMatch(String opponent) {
		System.out.println("Create match");
		ChannelService channelService = ChannelServiceFactory
				.getChannelService();
		UserService userService = UserServiceFactory.getUserService();
		User user = userService.getCurrentUser();
		Player white = getOrCreatePlayer(user.getEmail());
		Player black = getOrCreatePlayer(opponent);
		Match match = new Match(new Date());
		dao.createMatchTransction(match, white, black);
		System.out.println(match.getBlack());
		for(String channel: match.getBlack().getChannels()){
			if(channel == null){
				break;
			}
			channelService.sendMessage(new ChannelMessage(channel, "NB"+match.getMatchId()+"@"+match.getState()));
		}
		
		// TODO Auto-generated method stub
		return "NW"+match.getMatchId()+"@"+match.getState();
	}

	private Player getOrCreatePlayer(String email){
		Player player;
		if ((player = dao.getPlayer(email)) == null) {
			System.out.println("Player Not Found");
			player = new Player(email);
			dao.savePlayer(player);
		}
		System.out.println(player.toString());
		return player;
	}
	// private String getOther(String clientID){
	// return (clientID.equals(clientIDs[0]))?clientIDs[1]:clientIDs[0];
	// }
	/*
	 * static class SessionID{ private static final String AB =
	 * "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"; private static Random rnd = new
	 * Random();
	 * 
	 * public static String generate( int len ) { StringBuilder sb = new
	 * StringBuilder( len ); for( int i = 0; i < len; i++ ) sb.append(
	 * AB.charAt( rnd.nextInt(AB.length()) ) ); return sb.toString(); } }
	 * 
	 * class Game{ private String white; private String black;
	 * 
	 * public Game(String white, String black){ this.white = white; this.black =
	 * black; }
	 * 
	 * public String getOpponent(String myself){ return
	 * (myself.equals(white))?black:white; } }
	 */
	public static void clearChannel(String email){
		dao.clearChannels(email);
	}

	@Override
	public List<String> loadMatchList(String email) {
		// TODO Auto-generated method stub
		List<String> list = new ArrayList<String>();
		Player player = dao.getPlayer(email);
		if (player == null)
			return null;
		System.out.println(player.getMatches().size());
		list.add(">[select one]");
		for (Key<Match> m : player.getMatches()) {
			Match match = ofy().cache(false).load().key(m).getValue();
			if (match != null) {
				list.add(match.getMatchId() + ">" +match.getMatchId()+ "VS"+ match.getOpponent(email).toString()
						);
			}
		}
		return list;
	}
}
