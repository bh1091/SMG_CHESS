package org.wenjiechen.hw3;

import java.util.Set;

import org.shared.chess.Color;
import org.shared.chess.GameResult;
import org.shared.chess.Move;
import org.shared.chess.Piece;
import org.shared.chess.PieceKind;
import org.shared.chess.Position;
import org.shared.chess.State;
import org.shared.chess.StateChanger;
import org.shared.chess.StateExplorer;
import org.wenjiechen.hw2.StateChangerImpl;
import org.wenjiechen.hw2_5.StateExplorerImpl;
import org.wenjiechen.hw6.client.ChessGameService;
import org.wenjiechen.hw6.client.ChessGameServiceAsync;

import com.google.common.collect.Sets;
import com.google.gwt.appengine.channel.client.Channel;
import com.google.gwt.appengine.channel.client.ChannelError;
import com.google.gwt.appengine.channel.client.ChannelFactoryImpl;
import com.google.gwt.appengine.channel.client.SocketListener;

import com.google.gwt.event.dom.client.ChangeEvent;
import com.google.gwt.event.dom.client.ChangeHandler;
import com.google.gwt.event.dom.client.ClickEvent;
import com.google.gwt.event.dom.client.ClickHandler;
import com.google.gwt.event.dom.client.DragOverEvent;
import com.google.gwt.event.dom.client.DragOverHandler;
import com.google.gwt.event.dom.client.DragStartEvent;
import com.google.gwt.event.dom.client.DragStartHandler;
import com.google.gwt.event.dom.client.DropEvent;
import com.google.gwt.event.dom.client.DropHandler;
import com.google.gwt.event.dom.client.HasAllDragAndDropHandlers;
import com.google.gwt.event.dom.client.HasChangeHandlers;
import com.google.gwt.event.dom.client.HasClickHandlers;
import com.google.gwt.event.logical.shared.ValueChangeEvent;
import com.google.gwt.event.logical.shared.ValueChangeHandler;
import com.google.gwt.media.client.Audio;
import com.google.gwt.storage.client.Storage;
import com.google.gwt.user.client.History;
import com.google.gwt.user.client.Window;
import com.google.gwt.user.client.rpc.AsyncCallback;
import com.google.gwt.user.client.ui.Grid;
import com.google.gwt.user.client.ui.Widget;

public class Presenter {
	public interface View {
		/**
		 * Renders the piece at this position. If piece is null then the
		 * position is empty.
		 */
		void setPiece(int row, int col, Piece piece);

		void setHighlighted(int row, int col, boolean highlighted);

		void setWhoseTurn(Color color);

		void setGameResult(GameResult gameResult);

		void setLastMove(int row, int col, boolean lastmove);

		void setPromotionChoice(Color color);

		void setPromotionPromt(String str);

		void cleanPromotionPanel();

		void saveHistory(String token);

		void audioPlay();

		void newGridBoard();

//		HasClickHandlers getSaveButton();
//
//		HasClickHandlers getLoadButton();
//
//		HasClickHandlers getRestartButton();

		Widget getImage(int r, int c);

		Grid getGameBoard();

		void playFadeAnimation(Move move);

		void playSlowMoveAnimation(Move move);
		
		void playMoveSound();
		
		void addSocketListener(SocketListener listener);

		void MatchPlayer();

		void sendMove(String move);
		
		void setPlayer(String name, String color);
		
		void setOpponentPlayer(String name,String color, String email);
		
		void setLogoutURL(String logoutLink);

		HasAllDragAndDropHandlers addDnDListener(int row, int col);
		
		public void addItemToMatchList(String str);
		
		public HasChangeHandlers getMatchList();
		
		public int getIndexofSelectionFromMatchList();
		
		public void cleanMatchList();

		/**
		 * fetch match list for current player
		 */
		public void fetchMatchList(AsyncCallback<String> matchListCallback);
		
	}

	public View view;
	public State state;
	private StateChanger stateChanger;
	private StateExplorer stateExplorer;
	private Position firstClickPiecePos;
	private Set<Position> possibleMoveToPos;
	private PieceKind promotionKind;
	private boolean canPromotion;
	private Move moveFromMes = null;
	private Color playerColor;
	private State nullState = new State(null,new Piece[8][8],new boolean[2], new boolean[2],null, 0, null);
	private boolean[][] didSetDragHandler = new boolean[8][8];
	private String playerName;
	private String playerEmail;
	private Long matchId = new Long(0);
	private Long[] matchIdList;
	private String[] stateList;
	private String[] opponentNames;
	private String[] opponentColors;
	private String[] opponentEmails;
	
	public Presenter() {
		stateChanger = new StateChangerImpl();
		stateExplorer = new StateExplorerImpl();
		promotionKind = null;
		possibleMoveToPos = Sets.newHashSet();
	}

	public void setView(View view) {
		this.view = view;
		final View finalView = view;
		
		for (int row = 0; row < 8; ++row) {
			for (int col = 0; col < 8; ++col) {
				if (didSetDragHandler[row][col] == false) {
					didSetDragHandler[row][col] = true;
					final int r = row;
					final int c = col;
					HasAllDragAndDropHandlers image = view.addDnDListener(row,
							col);

					image.addDragStartHandler(new DragStartHandler() {
						@Override
						public void onDragStart(DragStartEvent event) {
							// Required: set data for the event.
							// event.setData("text", "Hello World");
							// Optional: show a copy of the widget under cursor.
							event.getDataTransfer()
									.setDragImage(
											finalView.getImage(r, c)
													.getElement(), 0, 0);
							System.out
									.println("presenter() onDragStart(): dragPiece");
							dragPiece(r, c);
						}
					});

					image.addDragOverHandler(new DragOverHandler() {
						@Override
						public void onDragOver(DragOverEvent event) {
							finalView.getImage(r, c).getElement().getStyle()
									.clearBackgroundColor();
						}
					});

					image.addDropHandler(new DropHandler() {
						@Override
						public void onDrop(DropEvent event) {
							event.preventDefault();
							// System.out.println("onDrop(): dropPiece");
							dropPiece(r, c);
						}
					});
				}
			}
		}
				
		view.addSocketListener(new SocketListener() {

			@Override
			public void onOpen() {
				Window.alert("If not matched, please press automatch button, invite other player via Email or choose match list");
				finalView.MatchPlayer();
			}

			@Override
			public void onMessage(String message) {
				
				if(message.contains("newEmailMatch")){
					System.out.println("parseMessageFromEmailMatch");
					parseMessageFromEmailMatch(message);
				}
				else{
					parseMessage(message);
				}
				
			}

			@Override
			public void onError(ChannelError error) {
				Window.alert(error.getCode() + ": " + error.getDescription());
			}

			@Override
			public void onClose() {
//				Window.alert("Channel closed!");
			}

		});
		
		view.getMatchList().addChangeHandler(new ChangeHandler() {
			public void onChange(ChangeEvent event) {
				updateMatchList();
				System.out.println("onChange() updateMatchlist");
				int matchIndex = finalView.getIndexofSelectionFromMatchList();
				System.out.println(matchIndex);
				if (matchIndex != -1) {
					loadStateWithMatchId(matchIndex);
				}
			}
		});
		
		//fetch match list from server and show in view
		updateMatchList();
	}
	
	public void parseMessageForLoginPlayer(String message){
//		System.out.println("setPlayer---" + message);
		String[] info = message.split("=");
		playerName = info[1];
		playerEmail = info[3];
		view.setPlayer(playerName, "unknown");
	}
	
	
	public void loadStateWithMatchId(int matchIndex){
		System.out.println("loadStateWithMatchId()");
		matchId = matchIdList[matchIndex];
		playerColor = opponentColors[matchIndex].equals("white") ? Color.BLACK : Color.WHITE;
		view.setPlayer(playerName, playerColor.toString());
		view.setOpponentPlayer(opponentNames[matchIndex], opponentColors[matchIndex], opponentEmails[matchIndex]);
		String statestr = stateList[matchIndex];		
		State matchState;
		if(statestr.equals("newgame") == true){
			matchState = new State();			
		}
		else{
			matchState = HistoryCoder.decodingHistoryString(statestr);
		}
		setState(matchState);				
	}
		
	/**
	 * fetch matchList from server and update matchlist box
	 */
	public void updateMatchList(){
		view.cleanMatchList();
		final View finalView = view;
		
		AsyncCallback<String> matchlistCallback = new AsyncCallback<String>() {
			@Override
			public void onFailure(Throwable caught) {
				Window.alert("Error: Cannot fetch match list from server!");
			}
			
			@Override
			public void onSuccess(String result) {
				String matchlist = result;
				if (matchlist != null) {
					String[] matchlines = parseMatchlistMsg(matchlist);
					for (String match : matchlines) {
//						match.substring(match.indexOf("your"), match.length());
//						System.out.println("onSuccess() match: " + match); 
						finalView.addItemToMatchList(match);
					}
				}// if
			}
		};				
		view.fetchMatchList(matchlistCallback);
	}
	
	
	public String[] parseMatchlistMsg(String matchlist){

		String[] matchlines = matchlist.split("#");
		System.out.println("parseMatchlistMsg(): matchlines.length : " + matchlines.length);
		String[] showlines = new String[matchlines.length];
		matchIdList = new Long[matchlines.length];
		stateList = new String[matchlines.length];
		opponentNames = new String[matchlines.length];
		opponentColors = new String[matchlines.length];
		opponentEmails = new String[matchlines.length];
		
		int i = 0;
		for(String line : matchlines){
			String[] tuples = line.split(";");
			
			for(String t: tuples){
				String[] token = t.split("=");
				if(token[0].equals("matchId")){
					matchIdList[i] = Long.parseLong(token[1]);
//					System.out.print("matchIdList[i] is " + matchIdList[i] );
				}
				else if(token[0].equals("color")){
					showlines[i] += " your color is " + token[1];
					if(token[1].equals("white")){
						opponentColors[i] = "black";
					}
					else{
						opponentColors[i] = "white";
					}
				}
				else if(token[0].equals("opponentName")){
					showlines[i] += ", opponent is " + token[1];
					opponentNames[i] = token[1];
				}
				else if(token[0].equals("opponentEmail")){
					showlines[i] += ", opponent Email is " + token[1];
					opponentEmails[i] = token[1];
				}
				else if(token[0].equals("state")){
					//null pointer***********
					stateList[i] = token[1];
//					System.out.print("stateList[i] : " + stateList[i] );
				}
			}
			++i;
		}
		return showlines;
	}
	
	public void parseMessageFromEmailMatch(String message){		
		String[] mes = message.split(">");
		if(mes[0].equals("newEmailMatch")){
			setEmailMatch(mes[1]);
		}		
	}
	
	public void setEmailMatch(String message){	
		Long id = new Long(0);
		Color color = null;
		String oppColor = "";
		String oppName = "";
		String oppEmail = "";
		
		String[] mes = message.split(";");
		for(String tuples : mes){
			String[] t = tuples.split("=");
			if(t[0].equals("matchId")){
				id = Long.parseLong(t[1]);
			}
			else if(t[0].equals("color")){
				if(t[1].equals("white")){
					color = Color.valueOf("WHITE");
					oppColor = "black";
				}
				else{
					color = Color.valueOf("BLACK");
					oppColor = "white";
				}
			}
			else if(t[0].equals("opponentName")){
				oppName = t[1];
			}
			else if(t[0].equals("opponentEmail")){
				oppEmail = t[1];
			}
		}//outer for
		
		boolean matched = false;
		//have matched
		if (matchId == 0) {
			matched = true;
			matchId = id;
			playerColor = color;
			view.setOpponentPlayer(oppName, oppColor, oppEmail);
			String playcolor;
			if(playerColor.equals(Color.WHITE)){
				playcolor = new String("White");
			}
			else{
				playcolor = new String("Black");
			}
			view.setPlayer(playerName, playcolor);
		}
		if (matched == false) {
			Window.alert("You receive a new game invitation! Please open a new browser to play");
			return;
		}
		updateMatchList();
	}
	
	public void parseMessage(String message){
		String[] mes = message.split("=");

		if (mes[0].equals("move")) {
			moveFromMes = decodeMove(mes[1]);
			cleanHighlight();
			stateChanger.makeMove(state, moveFromMes);
			setState(state);
			view.saveHistory(HistoryCoder
					.codingStateToHistory(state));
			view.playFadeAnimation(moveFromMes);
			view.playMoveSound();
			firstClickPiecePos = null;
			possibleMoveToPos.clear();
		} else if (mes[0].equals("player")) {
			if (mes[1].equals("white")) {
				playerColor = Color.WHITE;
				view.setPlayer(mes[2], "white");
				view.setOpponentPlayer(mes[4], "black","");
			} else {
				playerColor = Color.BLACK;
				view.setPlayer(mes[2], "black");
				view.setOpponentPlayer(mes[4], "white","");
			}
			setState(new State());
			playerName = mes[2];
		} else if (mes[0].equals("match")) {
			if (mes[1].equals("faild")) {
				Window.alert("Match faild, becasue of no other player.\nPlease wait for a moment");
				setState(nullState);
			}
		} else if (mes[0].equals("unmatched")) {
			Window.alert("disconnet Players. Rematch Please!");
			setState(nullState);
		} else if (mes[0].equals("lost opponent")) {
			System.out.println("***else if opponent logged out");
			Window.alert("lost opponent! Please rematch!");
			view.setPlayer(playerName, "unknown");
			view.setOpponentPlayer("", "", "");
			setState(nullState);
		} else if (mes[0].equals("wait")) {
			view.setPlayer(mes[1], "unknown");
			setState(nullState);
		}
	}

	/**
	 * call this method when click 1. highlight the cells that the piece can
	 * move to, and store these position in Set<Position> possibleMoveToPos 2.
	 * set position firstClickPiecePos = clickPos
	 * 
	 * @param clickPos
	 */
	public void dealWithClick(int row, int col) {
//		System.out.println("dealWithClick()");
//		System.out.println(state);
//		System.out.println("piece in state is:" + "(" + row + "," + col + ")_"
//				+ state.getPiece(row, col));
//		System.out.println(view.getGameBoard().getWidget(row, col).getClass()
//				.getName());
		if(playerColor!= null && playerColor.equals(state.getTurn()) == false){
			return;
		}
		if (state.getGameResult() != null) {
			return;
		}
		Position clickPos = new Position(row, col);
		if (!possibleMoveToPos.isEmpty()
				&& !possibleMoveToPos.contains(clickPos)) {
			cleanHighlight();
			view.cleanPromotionPanel();
			highlightPossibleStartPos();
			possibleMoveToPos.clear();
			return;
		}
		// first click
		if (state.getPiece(clickPos) != null
				&& state.getPiece(clickPos).getColor() == state.getTurn()
				&& stateExplorer.getPossibleStartPositions(state).contains(
						clickPos) == true) {
			System.out.println("first click");
			view.cleanPromotionPanel();
			canPromotion = ((state.getPiece(clickPos).getKind() == PieceKind.PAWN) == true && (state
					.getTurn() == Color.WHITE ? clickPos.getRow() == 6
					: clickPos.getRow() == 1) == true);
			if (canPromotion == true) {
				view.setPromotionChoice(state.getTurn());
			}
			cleanHighlight();
			firstClickPiecePos = clickPos;
			highlightPossibleMoveToPos(clickPos);
		}
			// capture opponent's pieces or move to a space
		else if (firstClickPiecePos != null
				&& possibleMoveToPos.contains(clickPos) == true
				&& (state.getPiece(clickPos) == null || state
						.getPiece(clickPos).getColor() != state.getTurn())) {

			System.out.println("second click");
			Move move;
			if (canPromotion == true) {
				if (promotionKind == null) {
					view.setPromotionPromt("You have to choose a promotion kind for Pawn!");
					return;
				}
				move = new Move(firstClickPiecePos, clickPos, promotionKind);
				promotionKind = null;
				canPromotion = false;
				view.cleanPromotionPanel();
			} else {
				move = new Move(firstClickPiecePos, clickPos, null);
			}
			view.sendMove(move.toString());
		}
	}

	/**
	 * clean highlight, makeMove, setState, save history and clean private
	 * variables.
	 * 
	 * @param move
	 */
	public void refreshState(Move move) {
//		cleanHighlight();
//		dropAudio.play();
//		stateChanger.makeMove(state, move);
//		setState(state);
//		view.saveHistory(HistoryCoder.codingStateToHistory(state));
//		firstClickPiecePos = null;
//		possibleMoveToPos.clear();
	}


	private Move decodeMove(String message){
		PieceKind proKind = null;
		if(message.contains("QUEEN")){
			proKind = PieceKind.QUEEN;
		}else if(message.contains("ROOK")){
			proKind = PieceKind.ROOK;			
		}else if(message.contains("BISHOP")){
			proKind = PieceKind.BISHOP;			
		}else if(message.contains("KNIGHT")){
			proKind = PieceKind.KNIGHT;			
		}
		message = message.substring(0, 12);
						
		Position from = new Position(Integer.parseInt(message.substring(1, 2)), Integer.parseInt(message.substring(3,4)));
		Position to = new Position(Integer.parseInt(message.substring(8,9)), Integer.parseInt(message.substring(10,11)));
		Move move = new Move(from, to, proKind);
		return move;		
	}
	

	public void afterSlowMove(Move move) {
		cleanHighlight();
		view.playMoveSound();
		stateChanger.makeMove(state, move);
		setState(state);
		view.saveHistory(HistoryCoder.codingStateToHistory(state));
		firstClickPiecePos = null;
		possibleMoveToPos.clear();
	}

	private void highlightPossibleMoveToPos(Position clickPos) {
		if(playerColor != null && playerColor.equals(state.getTurn()) == false){
			return;
		}
		Set<Move> moves = stateExplorer.getPossibleMovesFromPosition(state,
				clickPos);
		possibleMoveToPos.clear();
		if (moves != null) {
			for (Move m : moves) {
				if (canPromotion == false) {
					view.setHighlighted(m.getTo().getRow(), m.getTo().getCol(),
							true);
				}
				possibleMoveToPos.add(m.getTo());
			}
		}
	}

	public void getPromotionKind(int pos) {
		if (firstClickPiecePos != null && canPromotion == true) {
			switch (pos) {
			case 0:
				promotionKind = PieceKind.BISHOP;
				break;
			case 1:
				promotionKind = PieceKind.KNIGHT;
				break;
			case 2:
				promotionKind = PieceKind.ROOK;
				break;
			case 3:
				promotionKind = PieceKind.QUEEN;
				break;
			}
			// highlighted Pawn's possible move to positions
			for (Position m : possibleMoveToPos) {
				view.setHighlighted(m.getRow(), m.getCol(), true);
			}
		}// if
	}

	/**
	 * highlight possible start positions
	 */
	private void highlightPossibleStartPos() {
		if(playerColor != null && playerColor.equals(state.getTurn()) == false){
			return;
		}
		Set<Position> startPos = stateExplorer.getPossibleStartPositions(state);
		for (Position s : startPos) {
			view.setHighlighted(s.getRow(), s.getCol(), true);
		}
	}

	/**
	 * clean highlighted cells and highlighted last move cell
	 */
	public void cleanHighlight() {
		for (int r = 0; r < 8; r++) {
			for (int c = 0; c < 8; c++) {
				view.setHighlighted(r, c, false);
				view.setLastMove(r, c, false);
			}
		}
	}

	public void setState(State state) {
		this.state = state;
		view.setWhoseTurn(state.getTurn());
		view.setGameResult(state.getGameResult());
		cleanHighlight();
		for (int r = 0; r < 8; r++) {
			for (int c = 0; c < 8; c++) {
				view.setPiece(r, c, state.getPiece(r, c));
			}
		}
		if(playerColor != null && playerColor.equals(state.getTurn())){
			highlightPossibleStartPos();
		}
	}

	public State getState() {
		return this.state;
	}

	public void loadStorage(String token) {
		cleanHighlight();
		setState(HistoryCoder.decodingHistoryString(token));
		highlightPossibleStartPos();
	}
	
	public void saveStorage(Storage storage){
		if (storage != null) {
			storage.setItem("savedState",HistoryCoder.codingStateToHistory(state));
		}
	}

	public void viewBinder() {
		History.addValueChangeHandler(new ValueChangeHandler<String>() {
			@Override
			public void onValueChange(ValueChangeEvent<String> event) {
				String historyStr = event.getValue();
				if (historyStr.isEmpty()) {
					setState(new State());
				} else {
					System.out.println("History.addValueChangeHandler(): setState");
					setState(HistoryCoder.decodingHistoryString(historyStr));
				}
			}
		});

//		view.getSaveButton().addClickHandler(new ClickHandler() {
//			@Override
//			public void onClick(ClickEvent event) {
//				Storage storage = Storage.getLocalStorageIfSupported();
//				saveStorage(storage);
//			}
//		});
//
//		view.getLoadButton().addClickHandler(new ClickHandler() {
//			@Override
//			public void onClick(ClickEvent event) {
//				Storage storage = Storage.getLocalStorageIfSupported();
//				String token = storage.getItem("savedState");
//				loadStorage(token);
//			}
//		});
//
//		view.getRestartButton().addClickHandler(new ClickHandler() {
//			@Override
//			public void onClick(ClickEvent event) {
//				System.out.println("restart*********************");
//				setState(new State());
//			}
//		});
	}
	
	
	/**
	 * 
	 * @param row
	 * @param col
	 */
	public void dragPiece(int row, int col){		
		if(playerColor!= null && playerColor.equals(state.getTurn()) == false){
			return;
		}
		if (state.getGameResult() != null) {
			return;
		}
		Position dragPos = new Position(row, col);
		if (!possibleMoveToPos.isEmpty()
				&& !possibleMoveToPos.contains(dragPos)) {
			cleanHighlight();
			view.cleanPromotionPanel();
			highlightPossibleStartPos();
			possibleMoveToPos.clear();
			return;
		}
		if (state.getPiece(dragPos) != null
				&& state.getPiece(dragPos).getColor() == state.getTurn()
				&& stateExplorer.getPossibleStartPositions(state).contains(
						dragPos) == true) {
			System.out.println("drag piece");
			view.cleanPromotionPanel();
			canPromotion = ((state.getPiece(dragPos).getKind() == PieceKind.PAWN) == true && (state
					.getTurn() == Color.WHITE ? dragPos.getRow() == 6
					: dragPos.getRow() == 1) == true);
			if (canPromotion == true) {
				view.setPromotionChoice(state.getTurn());
			}
			cleanHighlight();
			firstClickPiecePos = dragPos;
			highlightPossibleMoveToPos(dragPos);
		}		
	}
	
	/**
	 * 
	 * @param row
	 * @param col
	 */
	public void dropPiece(int row, int col){
		Position dropPos = new Position(row,col);
		if (firstClickPiecePos != null
				&& possibleMoveToPos.contains(dropPos) == true
				&& (state.getPiece(dropPos) == null || state
						.getPiece(dropPos).getColor() != state.getTurn())) {
			System.out.println("drop piece");
			Move move;
			if (canPromotion == true) {
				if (promotionKind == null) {
					view.setPromotionPromt("You have to choose a promotion kind for Pawn!");
					return;
				}
				move = new Move(firstClickPiecePos, dropPos, promotionKind);
				promotionKind = null;
				canPromotion = false;
				view.cleanPromotionPanel();
			} else {
				move = new Move(firstClickPiecePos, dropPos, null);
			}
			view.sendMove(move.toString());
		}		
	}
}